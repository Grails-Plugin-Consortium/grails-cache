<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
                      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
    <head>
        <title>Cache Plugin 1.0.0.M2</title>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen, print" title="Style" charset="utf-8" />
        <link rel="stylesheet" href="../css/pdf.css" type="text/css" media="print" title="PDF" charset="utf-8" />
    <script type="text/javascript">
function addJsClass(el) {
    var classes = document.body.className.split(" ");
    classes.push("js");
    document.body.className = classes.join(" ");
}
    </script>
    </head>

    <body class="body" onload="addJsClass();">
        <div id="navigation">
            <ul>
                <li>
                    <div id="nav-summary" onmouseover="toggleNavSummary(false)" onmouseout="toggleNavSummary(true)">
                        <a href="../guide/index.html" class="button">Table of contents</a>
                        <div id="nav-summary-childs" style="display:none;">
                            
                            <div class="toc-item" style="margin-left:0"><a href="#introduction"><strong>1</strong><span>Introduction To The Cache Plugin</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#usage"><strong>2</strong><span>Usage</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#cacheTags"><strong>3</strong><span>GSP Cache Tags</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#grailsCacheAdminService"><strong>4</strong><span>Grails Cache Admin Service</span></a></div>
                            
                        </div>
                    </div>
                </li>
                <li class="separator selected">
                    <a id="ref-button" onclick="localToggle(); return false;" href="#">Quick Reference</a>
                </li>
            </ul>
        </div>
        <div id="header">
            <div class="images clearfix">
                
                
            </div>
            <p>Grails Cache Plugin</p>
        </div>


        <table id="colset" border="0" cellpadding="0" cellspacing="0">
            <tr>
                <td id="col1">
                    <div id="main" class="corner-all">

                        <span id='toggle-col1' class="toggle">(<a href="#" onclick="localToggle(); return false;">Quick Reference</a>)</span>

                        <div class="project">
                            <h1>Cache Plugin - Reference Documentation</h1>
                            <p><strong>Authors:</strong> Jeff Brown, Burt Beckwith</p>
                            <p><strong>Version:</strong> 1.0.0.M2</p>
                            
                        </div>

                        
                        <div id="table-of-content">
                            <h2>Table of Contents</h2>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#introduction"><strong>1</strong><span>Introduction To The Cache Plugin</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#changeLog"><strong>1.1</strong><span>Change log</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#usage"><strong>2</strong><span>Usage</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#configuration"><strong>2.1</strong><span>Configuration</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#dsl"><strong>2.2</strong><span>Cache DSL</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#annotations"><strong>2.3</strong><span>Annotations</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#cacheManager"><strong>2.4</strong><span>CacheManager</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#cacheTags"><strong>3</strong><span>GSP Cache Tags</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#grailsCacheAdminService"><strong>4</strong><span>Grails Cache Admin Service</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#clearingCaches"><strong>4.1</strong><span>Clearing Caches</span></a></div>
                            
                            <div style="clear:both" ></div>
                        </div>
                        
                        
<a name="1. Introduction To The Cache Plugin"><!-- Legacy link --></a>
<h1 id="introduction">1 Introduction To The Cache Plugin</h1>
The Grails Cache plugin provides powerful and easy to use caching functionality to Grails applications and plugins.<p class="paragraph"/>The plugin makes significant use of the caching abstraction provided by Spring 3.1.  This user guide will focus on taking advantage of that functionality specifically within the context of a Grails application.  For information on the underlying abstraction see <a href="http://static.springsource.org/spring/docs/3.1.x/spring-framework-reference/html/cache.html" target="blank">The Official Spring Documentation</a>.


<a name="1.1 Change log"><!-- Legacy link --></a>
<h2 id="changeLog">1.1 Change log</h2>
<h3>Version 1.0.0.M2 - May 12, 2012</h3>



<h1 id="usage">2 Usage</h1>
The cache plugin adds Spring bean method call, page fragment, and taglib caching to Grails applications. You configure one or more caches in <code>Config.groovy</code> and/or one or more Groovy artifact files with names ending in CacheConfig.groovy (for example FooCacheConfig.groovy, BarCacheConfig.groovy, and these can also be in packages) in <code>grails-app/conf</code> (or a subdirectory if in a package) using an implementation-specific DSL, and annotate methods (either in Spring beans (typically Grails services) or controllers) or taglib closures to be cached.<p class="paragraph"/>There are three annotations; <a href="../gapi/grails/plugin/cache/Cacheable.html" class="api">Cacheable</a>, <a href="../gapi/grails/plugin/cache/CachePut.html" class="api">CachePut</a>, and <a href="../gapi/grails/plugin/cache/CacheEvict.html" class="api">CacheEvict</a>. You use &#64;Cacheable to mark a method or taglib closure as one that should check the cache for a pre-existing result, or generate a new result and cache it. Use &#64;CachePut to mark a method or taglib closure as one that should always be evaluated and store its result in the cache regardless of existing cache values. And use &#64;CacheEvict to flush a cache (either fully or partially) to force the re-evaluation of previously cached results. The annotations are based on the annotations with the same name from Spring (<a href="http://static.springsource.org/spring/docs/3.1.x/javadoc-api/org/springframework/cache/annotation/Cacheable.html" target="blank">Cacheable</a>, <a href="http://static.springsource.org/spring/docs/3.1.x/javadoc-api/org/springframework/cache/annotation/CachePut.html" target="blank">CachePut</a>, and <a href="http://static.springsource.org/spring/docs/3.1.x/javadoc-api/org/
springframework/cache/annotation/CacheEvict.html" target="blank">CacheEvict</a>) and support the same syntax but may support extended functionality in the future.<p class="paragraph"/>This 'core' cache plugin uses an in-memory implementation where the caches and cache manager are backed by a thread-safe <code>java.util.concurrent.ConcurrentMap</code>. This is fine for testing and possibly for low-traffic sites, but you should consider using one of the extension plugins if you need clustering, disk storage, persistence between restarts, and more configurability of features like time-to-live, maximum cache size, etc. Currently the extension plugins include <a href="http://grails.org/plugin/cache-ehcache" target="blank">cache-ehcache</a>, <a href="http://grails.org/plugin/cache-redis" target="blank">cache-redis</a>, and <a href="http://grails.org/plugin/cache-gemfire" target="blank">cache-gemfire</a>.



<h2 id="configuration">2.1 Configuration</h2>
<h4>Config.groovy and artifact files</h4><p class="paragraph"/>The caching configuration can be specified in <code>Config.groovy</code> or &#42;CacheConfig.groovy files. Both approaches support <code>environments</code> blocks for environment-specific configuration, and you can specify the loading order, for example to support overriding values. One example of this might be a plugin that specifies a known load order, allowing you to choose a lower value in your file and override some or all of the plugin's configuration.<p class="paragraph"/>There are a few configuration options for the plugin; these are specified in <code>Config.groovy</code>.<p class="paragraph"/><table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th><strong class="bold">Property</strong></th><th><strong class="bold">Default</strong></th><th><strong class="bold">Description</strong></th></tr><tr class="table-odd"><td>grails.cache.proxyTargetClass</td><td><code>false</code></td><td>From the Spring Javadoc: "By default, all proxies are created as JDK proxies. This may cause some problems if you are injecting objects as concrete classes rather than interfaces. To overcome this restriction you can set the <code>proxy-target-class</code> attribute to <code>true</code> which will result in class-based proxies being created."</td></tr><tr class="table-even"><td>grails.cache.aopOrder</td><td>Ordered.LOWEST_PRECEDENCE</td><td>From the Spring docs: "Defines the order of the cache advice that is applied to beans annotated with &#64;Cacheable or &#64;CacheEvict. No specified ordering means that the AOP subsystem determines the order of the advice."</td></tr></table>



<h2 id="dsl">2.2 Cache DSL</h2>
The cache implementation used by this plugin is very simple, so there aren't many configuration options (compared to the Ehcache implementation for example, where you have fine-grained control over features like overflowing to disk, time-to-live settings, maximum size of caches, etc.) So there aren't many supported options in the cache configuration DSL, although each plugin's DSL parser is lenient and just logs warnings if you specify options that aren't understood. This lets you share configurations between applications that use different plugins.<p class="paragraph"/>You specify the cache configuration in <code>Config.groovy</code> under the <code>grails.cache.config</code> key, for example<p class="paragraph"/><div class="code"><pre>grails.cache.config = &#123;
   cache &#123;
      name 'messages'
   &#125;
   cache &#123;
      name 'maps'
   &#125;
&#125;</pre></div><p class="paragraph"/>or in a &#42;CacheConfig.groovy file in the <code>grails-app/conf</code> directory under the <code>config</code> key, for example<p class="paragraph"/><div class="code"><pre>config = &#123;
   cache &#123;
      name 'messages'
   &#125;
   cache &#123;
      name 'maps'
   &#125;
&#125;</pre></div><p class="paragraph"/>Both of these will create two caches, one with name "messages" and one with name "maps". You can also use attributes from other DSLs and they will be ignored, for example:<p class="paragraph"/><div class="code"><pre>grails.cache.config = &#123;
   cache &#123;
      name 'messages'
      eternal <span class="java&#45;keyword">false</span>
      overflowToDisk <span class="java&#45;keyword">true</span>
      maxElementsInMemory 10000
      maxElementsOnDisk 10000000
   &#125;
   cache &#123;
      name 'maps'
   &#125;
&#125;</pre></div><p class="paragraph"/>This configuration results in the same caches as the simpler one.<p class="paragraph"/><h4>Order</h4><p class="paragraph"/>You can configure your cache definitions to be loaded before or after others by setting the <code>order</code> attribute. Configurations with higher numbers are loaded later, so these can override previously-configured values, although there is no support for removing caches or cache attributes, only adding or overriding:<p class="paragraph"/><div class="code"><pre>order = 2000<p class="paragraph"/>config = &#123;
   cache &#123;
      name 'messages'
   &#125;
   cache &#123;
      name 'maps'
   &#125;
&#125;</pre></div>



<h2 id="annotations">2.3 Annotations</h2>
The <a href="../gapi/grails/plugin/cache/Cacheable.html" class="api">Cacheable</a> and <a href="../gapi/grails/plugin/cache/CacheEvict.html" class="api">CacheEvict</a> annotations proviated by the plugin have counterparts with the same names provided by Spring. See the <a href="http://static.springsource.org/spring/docs/3.1.x/spring-framework-reference/html/cache.html" target="blank">Spring documentation</a> for their usage and allowed syntax.<p class="paragraph"/><h4>Service method caching</h4><p class="paragraph"/>Given this simple service, you can see that the <code>getMessage</code> method is configured to cache the results in the <code>"message"</code> cache. The <code>title</code> parameter will be used as the cache key; if there were multiple parameters they would be combined into the key, and you can always specify the key using the Spring SpEL support. The <code>save</code> method is configured as one that evicts elements from the cache. There is no need to clear the entire cache in this case; instead any previously cached item with the same <code>title</code> attribute will be replaced with the current <code>Message</code> instance.<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">package</span> com.yourcompany<p class="paragraph"/><span class="java&#45;keyword">import</span> grails.plugin.cache.CacheEvict
<span class="java&#45;keyword">import</span> grails.plugin.cache.Cacheable<p class="paragraph"/>class MessageService &#123;<p class="paragraph"/>   @Cacheable('message')
   Message getMessage(<span class="java&#45;object">String</span> title) &#123;
      println 'Fetching message'
      Message.findByTitle(title)
   &#125;<p class="paragraph"/>   @CacheEvict(value='message', key='&#35;message.title')
   void save(Message message) &#123;
      println <span class="java&#45;quote">"Saving message $message"</span>
      message.save()
   &#125;
&#125;</pre></div><p class="paragraph"/>This service works with the <code>Message</code> domain class:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">package</span> com.yourcompany<p class="paragraph"/>class Message <span class="java&#45;keyword">implements</span> Serializable &#123;<p class="paragraph"/>   <span class="java&#45;keyword">private</span> <span class="java&#45;keyword">static</span> <span class="java&#45;keyword">final</span> <span class="java&#45;object">long</span> serialVersionUID = 1<p class="paragraph"/>   <span class="java&#45;object">String</span> title
   <span class="java&#45;object">String</span> body<p class="paragraph"/>   <span class="java&#45;object">String</span> toString() &#123;
      <span class="java&#45;quote">"$title: $body"</span>
   &#125;
&#125;</pre></div><p class="paragraph"/>Note that for in-memory cache implementations it's not required that the objects being cached implement <code>Serializable</code> but if you use an implementation that uses Java serialization (for example the Redis plugin, or the Ehcache plugin when you have configured clustered caching) you must implement <code>Serializable</code>.<p class="paragraph"/>To test this out, be sure to define a <code>"message"</code> cache in <code>Config.groovy</code> and save and retrieve <code>Message</code> instances using the service. There are <code>println</code> statements but you can also turn on SQL logging to watch the database access that's needed to retrieve instances that aren't cached yet, and you shouldn't see database access for cached values.<p class="paragraph"/><h4>Controller action caching</h4><p class="paragraph"/>In addition to caching Spring bean return values, you can also cache responses for web requests using the same annotations. Note that since caching is implemented only for methods (Spring creates a proxy for your cached class in the same way that it creates a transactional proxy to start, commit, and roll back transactions for transactional Grails services) so you cannot annotate action closures. This doesn't fail silently; your controller class will not compile since the annotations are only allowed on the class or on methods; since Closures are fields, the annotations aren't valid.<p class="paragraph"/>For example, in this controller the <code>lookup</code> action will use the <code>"message"</code> cache, so the first time you call the action you will see the output from the <code>println</code> statement but subsequent calls won't execute and you'll see the cached response instead. When you call the <code>evict</code> action the entire cache will be cleared (because of the <code>allEntries=true</code> attribute):<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">package</span> com.yourcompany<p class="paragraph"/><span class="java&#45;keyword">import</span> grails.plugin.cache.CacheEvict
<span class="java&#45;keyword">import</span> grails.plugin.cache.Cacheable<p class="paragraph"/>class TestController &#123;<p class="paragraph"/>   @Cacheable('message')
   def lookup() &#123;
      // perform some expensive operations
      println <span class="java&#45;quote">"called 'lookup'"</span>
   &#125;<p class="paragraph"/>   @CacheEvict(value='message', allEntries=<span class="java&#45;keyword">true</span>)
   def evict() &#123;
      println <span class="java&#45;quote">"called 'evict'"</span>
   &#125;
&#125;</pre></div><p class="paragraph"/><h4>If you can't use annotations</h4><p class="paragraph"/>Annotations aren't required, they're just the most convenient approach for configuration. If you like you can define caching semantics in <code>grails-app/conf/spring/resources.groovy</code> (or <code>resources.xml</code> if you like XML). This is also useful if you want to apply caching but can't edit the code to add annotations (for example if you have compiled classes in a jar).<p class="paragraph"/>This Spring BeanBuilder DSL code will configure the same behavior as the two annotations in the example service class:<p class="paragraph"/><div class="code"><pre>beans = &#123;<p class="paragraph"/>   xmlns cache: 'http://www.springframework.org/schema/cache'
   xmlns aop: 'http://www.springframework.org/schema/aop'<p class="paragraph"/>   cache.'advice'(id: 'messageServiceCacheAdvice',
                  'cache&#45;manager': 'grailsCacheManager') &#123;
      caching(cache: 'message') &#123;
         cacheable(method: 'getMessage')
         'cache&#45;evict'(method: 'save', key: '&#35;message.title')
      &#125;
   &#125;<p class="paragraph"/>   // apply the cacheable behavior to MessageService
   aop.config &#123;
      advisor('advice&#45;ref': 'messageServiceCacheAdvice',
              pointcut: 'execution(&#42; com.yourcompany.MessageService.&#42;(..))')
   &#125;
&#125;</pre></div>



<h2 id="cacheManager">2.4 CacheManager</h2>
The plugin registers an instance of the <a href="http://static.springsource.org/spring/docs/3.1.x/javadoc-api/org/springframework/cache/CacheManager.html" target="blank">CacheManager</a> iterface as the <code>grailsCacheManager</code> Spring bean, so it's easy to access using dependency injection.<p class="paragraph"/>The most common method you would call on the <code>grailsCacheManager</code> is <code>getCache(String name)</code> to access a <a href="http://static.springsource.org/spring/docs/3.1.x/javadoc-api/org/springframework/cache/Cache.html" target="blank">Cache</a> instance programmatically. This shouldn't be needed often however. From the <code>Cache</code> instance you can also access the underlying cache implementation using <code>cache.getNativeCache()</code>.


<h1 id="cacheTags">3 GSP Cache Tags</h1>
The plugin provides GSP tags which are useful for caching the result of evaluating sections of markup.  These tags allow for the result of evaluating sections of markup to be cached so subsequent renderings of the same markup do not have to result in the markup being evaluated again.<p class="paragraph"/>See the documentation for the <a href="../ref/Tags/block.html" class="tags">block</a> and <a href="../ref/Tags/render.html" class="tags">render</a> tags for more details.


<h1 id="grailsCacheAdminService">4 Grails Cache Admin Service</h1>
The plugin provides a service named <code>GrailsCacheAdminService</code> which supports various methods for administering caches.


<h2 id="clearingCaches">4.1 Clearing Caches</h2>
There are methods in GrailsCacheAdminService for clearing the caches used by the <a href="../ref/Tags/block.html" class="tags">block</a> and <a href="../ref/Tags/render.html" class="tags">render</a> tags.<p class="paragraph"/><div class="code"><pre>class ReportingController &#123;<p class="paragraph"/>    def grailsCacheAdminService<p class="paragraph"/>    def report() &#123;
        // clear the cache used by the blocks tag&#8230;
        grailsCacheAdminService.clearBlocksCache()<p class="paragraph"/>        // clear the cache used by the render tag&#8230;
        grailsCacheAdminService.clearTemplatesCache()<p class="paragraph"/>        &#8230;
    &#125;
&#125;</pre></div>

                    </div>
                </td>
                <td id="col2">
            <div class="local clearfix">
                <div class="local-title">
                    <a href="../guide/index.html" target="mainFrame">Quick Reference</a>
                    <span class="toggle">(<a href="#" onclick="localToggle(); return false;">hide</a>)</span>
                </div>
                <div class="menu">
                    
                    <div class="menu-block"><h1 class="menu-title" onclick="toggleRef(this.parentNode.childNodes[1])">Tags</h1><div class="menu-sub">
                        
                        
                        <div class="menu-item"><a href="../ref/Tags/block.html">block</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/render.html">render</a>
                        </div>
                        
                        </div>
                    </div>
                    
                </div>
            </div>
        </td>
            </tr>
        </table>

        <div id="footer">
            
            
        </div>



<script type="text/javascript" src="../js/docs.js"></script>

    </body>
</html>
